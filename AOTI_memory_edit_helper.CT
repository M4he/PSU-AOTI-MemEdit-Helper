<?xml version="1.0" encoding="utf-8"?>
<CheatTable CheatEngineTableVersion="45">
  <Forms>
    <MainWindowForm Class="TCEForm" Encoding="Ascii85">wO37V8${piuam6nkF:$wP1RBcRYggarXO%Xr4qz$]hgM{Vz:dHjd#c1CF7Z8cAUgW,;kgS?gsWW1})**@9zc@ksBO2fslA-cD!G9LW@iCIre)yeV[Mv-Y-8pWm%o:yVspgYvV2#!@JHeuqOfY[]do$w?Lc4Y=l]9lVIS;?}=Ke!$bR%]6q!V^qpyAW8Ia)9%+qV1+cBEH/FUGt^?SSwI(xH5f5C;qFTKdw8xPo!!5![*n2d[uwWQ]Ml7d:Lm6/k?Yc4EnZ)f.wIvql5d+s-B53[#:K/OxLoUW;!wV$3PiRO4,PkrKv*-ZsVKPBii$71$(9@w@!l{5l9Z.{VzY93mT0RzSBAxpBhwTU5+8TOJ[C{]}f2GemE@Sim=#9oy1L@uswI4plBEUULVk.kwFb)9]ar(R$5x6g%hpa[.M4Y8Og/bWczgc,5,CJZR(dxZXzNl]tHXlRCiVWxGn*-j.s)}:}1RsS;esH_U54w;ABDyXXUZmBr8xwK9C?FEu7fME+Z(PkBZet-Ckk+2GKrQ9(ZiKF*9WoeEESwFd0]n;-.2iMRgy09?lzEj)2lpN-8Ewm(2Giqg6lK7af3glkGgnH]TsQ/xQ)1d1EG5f223VRp,iE81D92t+N!?[3FX)i:Y#^uR5@]MSm[+lrfj%UwZ!*Fs)k.%([=^qyB{lZifxGLxUQjOMSRY6M,Ig}0XtD(}B]nL/(!xlI]Xz.W:]gmmIsG*s+Fjjy*xk6Cxi}Fb6,pa,dxTcZ-y1QV(V/g3noi4L^4vGYyn@EBkd6-dc#j}*5#Gb9mV,T4kVX_D6tDpv5];wDhRP)oMm=gA+J5Z_hYI9c0%nn[+DjV4yFM]rFHRsG+N[=p)pM;?bL-^.k^oHLq2MlwqFV)_iKADtj-bx4B)Y3St)o5J/B79+r2d(Cns?0A?p4^j9f4UC;L+#3r]@}/H.gsTl)m!dS*MnUVSk:DJ)Eq0Xp$MXUS@Yv54Yu+lG.K*YI5q.]q3i;]9lLntX$C5[:CDq$:2(hQ#L.I?oY7Gnb3Srhy1rmH2ZuKa[POK7BA1P#nfn[BImLYa(s#7^zKw?NsC-D(fiZ)-q];S698y70By41dp.xi1xXI1MmW-fb?#DgP!]:Gm?BletD1+zY=IwBJHhhzM0.fjjZ9NeWfj1TMdZMRVLBl2ND!nUp=x396Z9YgydjKK+HZ5yS2a7dOx6Z#Xu#DY:_giE[.ASMT(y(z-}cKIo_Cwgf)S*Wv*(rorUb*}2LDhlXv^_d2}rQc.0G{XRh1vsr%=#T/toBqNXOci,$VT9x?O=7s%NZG@#Va$2{krL6[X$eY}p[HIa53=#1}5NBN8}/()ErU4sj5Ol*0oUReAS]h+Rlq)$:3@+/32qbOx?r5_-8zJE(vqfEov_.^-!,kLgOjy=/?x,PhzRsTH5$AWi56tKQjx@x/)ioe{CiYy.l73tcwkLd6(rviX$e./n-9e9Fa+b*6CFI=7x{oWav(U+BFuy-?[Ok(i;N./S9==h?{/W,iaoZCmp2n3V@(m.r_:oe65(fI63gdOHTyA5n??rO_T0TsqQ**5k7ZMSLXt0RSV=U0ca+OKPW93u{YGOIKBe!VvqfPW,$M^x2E-?05}Joz28dnD$%.ifZAt/xr?K,#xP3+^a5Lh3sKEBGF2vO^iXQZ0i]j-6U*Poy/C@uHFw}HS.-/]%3qB$MpAX,dN{;,$5GRWGRSM2r2HL@Jz#EN+f04V}uipy{B}HqZYgsdTaSefWh!kfNUCIJ:Xlc.*_UfHFr,urc@c}$^VHJ@t1muYWOW5HT.a):?}S:lB!]bnH4dNdkKu(diZ;2P4{,G12tnd%*MN5vX:_JDFxtUczD$S4t+Za%n+^06l6M:%cI{Z*ox]cK99Ebb,jR11PMJUV4bHhJh.$vaE68{vzf}SDNtu,C0xpKJ/Z;r*)gn@ZUM^?s%AYE.FSu;F6ti{KuK3Mp2Dw0])q931H/Z4Ci$B/3S5*=c}S4:L[M7mwKBD+tMp=qq-XBwlcnlO]a;,8gX(gsIiK#Kscn_.p)au6gMVwGR?[4C%Zy9iHi]E=cg%#7dd$gCEns+iBX1hiD,wdcmOfo%q7F7Yd?!Iy_M+T?PeMrfH+01KwozictQLf,nz)d$UsJ{X)]{,kO^/cPj=J8F8BJd1u9DMx[Tpl^bnSCGH4K#+il$V$@qeZaF/YhB@z:{*tbYI</MainWindowForm>
    <PartnerCardHelpForm Class="TCEForm" Encoding="Ascii85">byLl5)=Ae+lQv211]Y?z@*wU-F32qfE/K?GM6DE1MIty;8,#J3ve}tE$Dw(JUWC]-!t6Rt18Qx[[Ky9^[v6^a^V1AT56]-j=DNpr/,E#HNu$k#EiO?2zP3NY8MWiR(LzruN$pR2=TM,^zoUa6vY?hkyq64(Ezn-(M!V![D#vR[xcq^.j:GtsNE,Qa[U$fU).qwm*LNN+.f@vTQPZ{4)yZ@gA7n-u,wJ9QEY%8aJT#iprr6EZK#6:2kFwEsw9Yei(r@S%MLjk)5;r(q32+5pXUc}0rgmbE!B.D{v-Kp^YQ5UH]m;dO@tu(A=?_}OYX;S3:3/E.bOFkU0?kLske9-WoY1EIxF4UVaLuytzjvTn2ao^*POK0rBiV?uyk}$#:isDaIfZXH/3f1=Mh8wZ6[{ZS=8m?I$#HT:GDd_CA5zFl%onG%(iy?rs!iJ7x(z@$KqoC00r4=}tK__4DG1fNQ55ugdvC!a*mD48TTYUs5L_8%HLRrAhVjO66mwG)%$VMX*(P7*79UILt0DGP3WA[m;Nyw-8}uJI@m@,#6sP7E9sHC@f!vWUs+0})3:]-%x[.cq-ibc1t;vNO?1zczQ/(?mghl;6l0g/2Avp{qYF5)8DVwe{Np:78B[n*b#g0XeHR17Qk{#XS:zaiSl+sSxBO]dY8Nt?mFoDTt0*O3ao_g{78{^MI*+*=o?!,NiwK1(}CY[lZ7+$07D2$th_BTf{e+p</PartnerCardHelpForm>
    <AppearanceTransferHelpForm Class="TCEForm" Encoding="Ascii85">byUr6)=Ae+6WRo*5eGOSfrfHv1,q%^Rc}$7sFi_Lk,g[YwXrAms[R^AcilEmz:5aW8F)08gGXR==Zk.Fi4=]2Z?!/IwSQ}_!Q[0n-/b=fhDzs8kBS1BW-]VJ^hAr-Qxt[OJs9E4wnb}{6nUE2[V11ML;29y!RA,/+sT3+qj#*yg8D30)*6}cd@_T6@Uo.Dpfg}F/w_b7baaO;$Veo%sG$+rh2r*:aFlkb*2pr+GMfV;l/st6G3Me1bvRVgM%B$uERF=;ufx$]bcxzH$/9IKzWYI!LXOxJ#ghyf8NG[h#Z*EpD?=fc]C6SiUh9!d+V=MX^b;?sYP[==yRE$gm(WQcc2IM8uQh+fZ07:dTQhU4MADm=3rU6qml+WUnWnV9sT*:ouB96@0UletvyJ]IuoNr+4.SnC/:4{CUI+xJECOtQZ[}}+ZeUhQ=-OE]7bp$0XuxI((L+fCFmUw!u,XYd,C$x;KzSmH;d]s7Mn!u7lc@%:hyCzP1VgRzx:OH_(H%)3Nr6Zu-a?/;Vm{1;,.W=FxM4X0RR_^(NYRZ2SY:B_gt.o}4kj(F/qdh!g9y$lLrd.T)pfe159Mnx1.%[fcQm!KGqbWsl1k8Ujfp3H8@MWmOpZ5o-j,[,QbZNm=l*CJqChH3bxfQ:!*}x=pO(]Cuz)0$VE$].(*azy!G*:iJ6_xS#_/u-DADXVVoPW?kvq362dY$7)$P-6N}ztcTC=8_-$yV}sUm{J@g@-3j_nW)DXxHN?1)M%ucngmICJoNFC=-$*S=h]vgTzztYkRyg={S;?%sYYc(O,37_^!Zr;Q$1zJbfM9v19kltz#]ms+u,Mu/cyy.t+5JUXxL9Mm)HDJ]Or?%+167[Y64e7U2))gOwRoJks]?0c[Ndb+UPXiEU[S.ItCcPf$;YtMQR1b,b</AppearanceTransferHelpForm>
    <ItemExchangeHelpForm Class="TCEForm" Encoding="Ascii85">jg-M_,eQ$EX)[Q4%4]p9Py[+zNiMmhYMQne135H.ofvRiqf%P+6s+XRxX5aU+d0pNtMuGA$!p^haxHqz=2=pZqXjCRxYYjh%_HL;kHaLHUY/QWnvPG.$SuD-XI!3M/*yL/e2u0Ghqo=p(i%i7hp$mDO73U9^+/czi-X)0;w=SvorB;@as_5coU9*n(-7(DMdv59b#gRT6;GAGUj)?m2nC=4a6C2_EpK(*(2uMvdrXGh)I7VyZC2;gi{A(8:zNendOix?XURa(FVqapy%Lo]ywy=x,X8QEuND^@:-p{gd!I-A4?ryv:Z@9IH9FANv#ay*%AcfXWO,2/jltpJ,]lAK4Cnrhm6AqVOoo?r3425yq_HOPGDvoaUol=sbwF+_Q3IHE2ER]NVQ/g@^:Ee{e%O/Fl=az5F/A(ofLmNI#Ee2zz=?u]%DGcHi)^ad6+($s94(!GVy3,4Oy0mkEip@EbW_[O[$r)^;F(V1w$Xx7mQG8OOM9^obJQyY*e*UKk#)SKk*]d=uQ*fDGs(rkN^J%PW0@,)Da=pVIm@.?sq,%VIS{u)L$iU{qd@{UgCBpHo)ExI@$ww}vNX2u4Y7w:(5$c:iD8C/wWO6aD;c0o#zNQwy+Si$BfqJP%Fzo-XewxVSZj[JWa*(g(SSZ$)ndNZ?y*a1TCOyp8;)SVwUJh;tcfzh,ZiGS6j-ufZ.iLOjxFqsB=e4FJA(3(WdptRyoa8po(wSa3bIcaDwI-I3}JmFjg;r+,cZv$uH_qqdk[9Cd%Jw!h}Q?jaY[E@mgM6ugLfr@-.Q9yVU%55qEm*c5nOS+h)zO]kKi)RedC;2awQ5RPI*DsRV49@7rv7VE^r_MKW-_06M]g%/;N5yn10*g3glDDpNl9mk%/c5=/-tilmBu1hY[4Fmsn]UA%u{GvWHfm%8/EsHjr-;ShGR!xkI$D)rSN=3?xbM=NM[f[$3Md566BcMt:h1NbFnIy-{}VG0:oPOIO/KnN,W3Y0PdS67}RI=3KdeQI?[En-_dSyRw?(w^X[tM^zL@Is7dk?EX-SkQ7EA3R%oNgip:G3_m^{]lB1kOFjV</ItemExchangeHelpForm>
  </Forms>
  <CheatEntries>
    <CheatEntry>
      <ID>0</ID>
      <Description>"Character name"</Description>
      <ShowAsSigned>0</ShowAsSigned>
      <VariableType>String</VariableType>
      <Length>16</Length>
      <Unicode>1</Unicode>
      <CodePage>0</CodePage>
      <ZeroTerminate>1</ZeroTerminate>
      <Address>"PsuIlluminusOff.exe"+0095DEF8</Address>
      <Offsets>
        <Offset>540</Offset>
      </Offsets>
      <CheatEntries>
        <CheatEntry>
          <ID>47</ID>
          <Description>"Meseta"</Description>
          <ShowAsSigned>0</ShowAsSigned>
          <VariableType>4 Bytes</VariableType>
          <Address>+B8</Address>
        </CheatEntry>
      </CheatEntries>
    </CheatEntry>
  </CheatEntries>
  <UserdefinedSymbols/>
  <LuaScript>PROCESS_NAME = "PsuIlluminusOff.exe"
HELPER_VERSION = "1.2"

local offsets = {}
-- hex offset from the character name starting byte where meseta value is
offsets.meseta = "B8"
-- hex offset from the character name starting byte where appearance data is
offsets.charbody = "43"
-- length of the appearance data in bytes
offsets.charbody_len = 94
-- number of maximum characters of character names
local charname_len_limit = 16

local ids = {}
-- 0x11020000 = Photon Eraser
ids.item_photon_eraser = { 17, 2, 0, 0 }
-- 0x11020100 = Photon Reflector
ids.item_photon_reflector = { 17, 2, 1, 0 }
-- 0x0B013F00 = Sonic
ids.item_sonic = { 11, 1, 63, 0 }
-- 0x0B014100 = Tails
ids.item_tails = { 11, 1, 65, 0 }

-- partner cards and their unlock offsets in memory
local cards = {
  { "regular", "1CC8", "Laia Martinez" },
  { "regular", "1C80", "Lou" },
  { "regular", "1CA4", "Fulyen Curtz" },
  { "regular", "1C78", "Maya Shidow" },
  { "regular", "1C74", "Lucaim Nav" },
  { "regular", "1C68", "Hyuga Ryght" },
  { "regular", "1C70", "Leogini Berafort" },
  { "regular", "1C98", "Alfort Tylor" },
  { "regular", "1C7C", "Tonnio Rhima" },
  { "regular", "1CE8", "Ethan Waber (Rogue)" },
  { "regular", "1D0C", "Partner Machine" },
  { "hidden", "1C6C", "Karen Erra" },
  { "hidden", "1C84", "\"Mirei Mikuna\" (Lou without hat)" },
  { "hidden", "1C8C", "No Vol" },
  { "hidden", "1C88", "Hiru Vol" },
  { "hidden", "1C90", "Do Vol" },
  { "hidden", "1CC0", "Hal" },
  { "hidden", "1CA8", "Renvolt Magashi" },
  { "hidden", "1CB0", "Remlia Norphe" },
  { "hidden", "1C94", "Liina Sukaya" },
  { "hidden", "1C9C", "Obel Dallgun" },
  { "hidden", "1CDC", "Orson Waber" },
  { "hidden", "1CCC", "Karen (disguised as Mirei Mikuna)" },
  { "hidden", "1CFC", "Howzer" },
  { "hidden", "1CE4", "Bruce Boyde" },
  { "hidden", "1D04", "Lumia Waber" },
  { "hidden", "1D08", "Laia Martinez (President)" },
  { "hidden", "1D00", "Rutsu" },
  { "hidden", "1CA0", "Ethan Waber (normal outfit)" },
  { "broken", "1C64", "Ethan Waber" },
  { "broken", "1CB4", "Clamp Maniel" },
  { "broken", "1CB8", "Kanal Tomrain" },
  { "broken", "1CAC", "Lumia Waber" },
  { "broken", "1CBC", "Mina (receptionist)" },
  { "broken", "1CC4", "Fulyen Curtz (without helmet)" },
  { "broken", "1CE0", "Fulyen Curtz" },
  { "broken", "1CEC", "Vivian" },
  { "broken", "1CF0", "Helga Neumann" },
  { "broken", "1CF4", "Hakana Kutanami" },
  { "broken", "1CF8", "Liche Baratse" },
  { "broken", "1CD0", "(real) Mirei Mikuna" },
  { "broken", "1CD4", "Obel (armor suit)" },
  { "broken", "1CD8", "Maira Klein" }
}

-- calculate the starting address of the memory region containing the
-- character data (character name, meseta, appearance, inventory etc.)
function charBaseAddr()
  return "[" .. PROCESS_NAME .. "+0095DEF8]+540"
end

-- buffer with handles to all initialized checkboxes for partner cards
local card_checkboxes = {}

-- auto attach routines
local autoAttachTimer = nil ---- variable to hold timer object
local autoAttachTimerInterval = 1000 ---- Timer intervals are in milliseconds
local autoAttachTimerTicks = 0 ---- variable to count number of times the timer has run
local autoAttachTimerTickMax = 5000 ---- Set to zero to disable ticks max
local function autoAttachTimer_tick(timer) ---- Timer tick call back
        ---- Destroy timer if max ticks is reached
  if autoAttachTimerTickMax &gt; 0 and autoAttachTimerTicks &gt;= autoAttachTimerTickMax then
    timer.destroy()
  end
        ---- Check if process is running
  if getProcessIDFromProcessName(PROCESS_NAME) ~= nil then
    timer.destroy() ---- Destroy timer
    openProcess(PROCESS_NAME) ---- Open the process
    MainWindowForm.label_attach_state.Color = 0x00FF00
    MainWindowForm.button_load.Enabled = true
  end
  autoAttachTimerTicks = autoAttachTimerTicks + 1 ---- Increase ticks
end

function initTimer()
  autoAttachTimer = createTimer(MainWindowForm)
  autoAttachTimer.Interval = autoAttachTimerInterval
  autoAttachTimer.OnTimer = autoAttachTimer_tick
end

--- helper function: compare two tables
local function tableEq(tbl1, tbl2)
  return (
    table.concat(tbl1, ':') == table.concat(tbl2, ':')
  )
end

-- helper function: initialize a checkbox on a form
function initCheckbox(x, y, name, caption, parent)
  local ret = parent.findComponentByName(name)
  if ret == nil then
    for i=1,#card_checkboxes do
      local box = card_checkboxes[i]
      if box.getName() == name then
        ret = box
        break
      end
    end
  end
  if ret == nil then
    ret = createCheckBox(parent)
  end
  ret.Left = x
  ret.Top = y
  ret.Name = name
  ret.Caption = caption
  return ret
end

-- callback routine for changed partner card checkboxes
function partnerCardCheckBoxCallback(sender)
  -- the offset of the value to change in memory is encoded in
  -- each checkbox's name after the underscore
  local offset = sender.getName():gsub("card_", "")
  if sender.Checked then
    writeByte(charBaseAddr() .. "+" .. offset, 3)
  else
    writeByte(charBaseAddr() .. "+" .. offset, 0)
  end
end

-- initialize all checkboxes for partner cards based on the cards table
function initCardCheckboxes()
  local y_reg = 0
  local y_bon = 0
  local y_bro = 40
  local height = 20
  local x = 8
  card_checkboxes = {}
  for i, card in ipairs(cards) do
    local ctype = card[1]
    local offset = card[2]
    local name = card[3]

    if ctype == "regular" then
      local box = initCheckbox(
        x, y_reg, "card_" .. offset,
        name, MainWindowForm.box_story_cards
      )
      table.insert(card_checkboxes, box)
      y_reg = y_reg + height
    elseif ctype == "hidden" then
      local box = initCheckbox(
        x, y_bon, "card_" .. offset,
        name, MainWindowForm.box_bonus_cards
      )
      table.insert(card_checkboxes, box)
      y_bon = y_bon + height
    elseif ctype == "broken" then
      local box = initCheckbox(
        x, y_bro, "card_" .. offset,
        name, MainWindowForm.box_broken_cards
      )
      table.insert(card_checkboxes, box)
      y_bro = y_bro + height
    end
  end
end

-- completely (re)initialize the main window
function resetState()
  MainWindowForm.Caption = "Phantasy Star Universe AOTI Memory Edit Helper v" .. HELPER_VERSION
  if autoAttachTimer ~= nil then
    autoAttachTimer.destroy()
  end

  MainWindowForm.label_attach_state.Color = 0x0000FF
  MainWindowForm.button_load.Enabled = false
  MainWindowForm.edit_charname.Enabled = false
  MainWindowForm.edit_meseta.Enabled = false
  MainWindowForm.button_charname.Enabled = false
  MainWindowForm.button_meseta.Enabled = false
  MainWindowForm.box_story_cards.Enabled = false
  MainWindowForm.box_bonus_cards.Enabled = false
  MainWindowForm.box_broken_cards.Enabled = false
  MainWindowForm.button_charbody_export.Enabled = false
  MainWindowForm.button_charbody_import.Enabled = false
  MainWindowForm.edit_charbody.Enabled = false
  MainWindowForm.button_photon_replace.Enabled = false

  MainWindowForm.edit_charname.Text = "(not loaded)"
  MainWindowForm.edit_meseta.Text = "(not loaded)"
  MainWindowForm.edit_charbody.Text = "(press Record to load values)"

  -- uncheck all checkboxes
  for i=1,#card_checkboxes do
    local box = card_checkboxes[i]
    local nam = box.getName()
    if nam:sub(1, #"card_") == "card_" then
      -- temporarily disarm the checkbox OnChange to prevent triggering code
      -- when setting .Checked
      box.OnChange = nil
      box.Checked = false
      box.OnChange = partnerCardCheckBoxCallback
    end
  end
end

function readCharnameValue()
  local str = readString(charBaseAddr(), 2 * charname_len_limit, true)
  MainWindowForm.edit_charname.Text = str
end

function readMesetaValue()
  local meseta_int = readInteger(charBaseAddr() .. "+" .. offsets.meseta)
  MainWindowForm.edit_meseta.Text = tostring(meseta_int)
end

function MainWindowForm_button_loadClick(sender)


  MainWindowForm.box_story_cards.Enabled = true
  MainWindowForm.box_bonus_cards.Enabled = true
  MainWindowForm.box_broken_cards.Enabled = true
  MainWindowForm.edit_charname.Enabled = true
  MainWindowForm.edit_meseta.Enabled = true
  MainWindowForm.button_charname.Enabled = true
  MainWindowForm.button_meseta.Enabled = true
  MainWindowForm.edit_charbody.Enabled = true
  MainWindowForm.button_charbody_import.Enabled = true
  MainWindowForm.button_charbody_export.Enabled = true
  MainWindowForm.button_photon_replace.Enabled = true

  -- update the current fields
  readCharnameValue()
  readMesetaValue()

  -- set checkboxes to reflect the cards currently unlocked
  for i=1,#card_checkboxes do
    local box = card_checkboxes[i]
    local nam = box.getName()
    if nam:sub(1, #"card_") == "card_" then
      local offset = nam:gsub("card_", "")
      local value = readByte(charBaseAddr() .. "+" .. offset)
      if value == 3 then
         box.Checked = true
      else
         box.Checked = false
      end
    end
  end
end

-- change Meseta
function MainWindowForm_button_mesetaClick(sender)
  local meseta = MainWindowForm.edit_meseta.Text
  local meseta_int = tonumber(meseta)
  if meseta_int == nil then
    showMessage("Not a valid number!")
    readMesetaValue()
    return
  end
  if meseta_int &lt; 0 or meseta_int &gt; 999999999 then
    showMessage("Invalid Meseta value (too small or large)!")
    readMesetaValue()
  end
  writeInteger(charBaseAddr() .. "+" .. offsets.meseta, meseta_int)
  readMesetaValue()
  showMessage("Meseta changes are only visible in the inventory after loading screens, e.g., go through a door.\nChange is only permanent if the game is saved.")
end

-- change character name
function MainWindowForm_button_charnameClick(sender)
  local charname = MainWindowForm.edit_charname.Text
  if string.len(charname) &lt; 1 then
    showMessage("Character name must not be empty!")
    return
  end
  if string.len(charname) &gt; charname_len_limit then
    showMessage("Character name must not be longer than " .. tostring(charname_len_limit) .. "!")
    return
  end
  -- 1 letter = 2 bytes
  num_clear_bytes = charname_len_limit*2
  -- overwrite character name region with 0x00
  for i=0,num_clear_bytes-1 do
    writeByte(charBaseAddr() .. "+" .. string.format("%X", i), 0x00)
  end
  -- write new character name
  writeString(charBaseAddr(), charname, true)
  readCharnameValue()
  showMessage("Character name changes are only visible after loading screens, e.g., go through a door.\nChange is only permanent if the game is saved.")
end

-- read character appearance data from memory
function MainWindowForm_button_charbody_exportClick(sender)
  local body_table = readBytes(
    charBaseAddr() .. "+" .. offsets.charbody,
    offsets.charbody_len, true
  )
  MainWindowForm.edit_charbody.Text = table.concat(body_table, ",")
  MainWindowForm.edit_charbody.Enabled = false
end

-- apply character appearance data
function MainWindowForm_button_charbody_importClick(sender)
  local body_values = MainWindowForm.edit_charbody.Text
  local body_bytes = {}
  local i = 1
  -- split the string at "," characters and load it into a table of integers
  for val in body_values:gmatch(string.format("([^%s]+)", ",")) do
      local val_int = tonumber(val)
      if val_int == nil or val_int &lt; 0 or val_int &gt; 255 then
        showMessage("Character appearance data is invalid and can't be imported!")
        return
      end
      body_bytes[i] = val_int
      i = i + 1
  end
  if #body_bytes ~= offsets.charbody_len then
    showMesssage("Character data has invalid length and can't be imported!")
    return
  end
  if MainWindowForm.radio_body_all.Checked then
    writeBytes(charBaseAddr() .. "+" .. offsets.charbody, body_bytes)
    showMessage("Applied full appearance.\nPlease go through any door to apply.\nChange is only permanent if the game is saved.")
  end
  if MainWindowForm.radio_body_proportions.Checked then
    -- appearance memory is 94 bytes
    -- 91 .. 94 = face proportions y axis
    -- 87 .. 90 = face proportions x axis
    -- 83 .. 86 = body proportions y axis
    -- 79 .. 82 = body proportions x axis
    -- 75 .. 78 = body height
    for i=75,86 do
      local hex_offset = string.format("%x", i-1)
      writeByte(
        charBaseAddr() .. "+" .. offsets.charbody .. "+" .. hex_offset,
        body_bytes[i]
      )
    end
    showMessage("Applied body proportions only.\nPlease go through any door to apply.\nChange is only permanent if the game is saved.")
  end
end

-- exchange Photon Eraser/Reflector items
function MainWindowForm_button_photon_replaceClick(sender)
  --- inventory starts at offset +0x258 (+600 decimal)
  local inventory_start_addr = charBaseAddr() .. "+258"
  --- each entry is 36 bytes, total of 60 slots
  local inventory_bytes = readBytes(
    inventory_start, 60*36, true
  )
  local eraser_addr = nil
  local reflector_addr = nil
  for i=0,59 do
    -- each item is 36 bytes long, ID starts at byte 9
    local item_id_offset = string.format("%X", i*36+8)
    local item_id_addr = inventory_start_addr .. "+" .. item_id_offset
    local item_id = readBytes(item_id_addr, 4, true)
    if tableEq(item_id, ids.item_photon_eraser) then
      if eraser_addr ~= nil then
        showMessage("ERROR: Found Photon Eraser twice in inventory, this should never happen!")
        return
      end
      eraser_addr = item_id_addr
    elseif tableEq(item_id, ids.item_photon_reflector) then
      if reflector_addr ~= nil then
        showMessage("ERROR: Found Photon Reflector twice in inventory, this should never happen!")
        return
      end
      reflector_addr = item_id_addr
    end
  end
  if eraser_addr == nil then
    showMessage("ERROR: Photon Eraser was not found in inventory.\nCannot replace items!")
    return
  elseif reflector_addr == nil then
    showMessage("ERROR: Photon Reflector was not found in inventory.\nCannot replace items!")
    return
  end
  writeBytes(eraser_addr, ids.item_sonic)
  writeBytes(reflector_addr, ids.item_tails)
  showMessage("Replaced both items!\nSave the game to make changes permanent.\nChanges will only be visible after loading the save.")
end

-- help popup for partner cards
function MainWindowForm_button_help_cardsClick(sender)
  PartnerCardHelpForm.Show()
end

-- help popup for character appearance transfer
function MainWindowForm_button_help_charbodyClick(sender)
  AppearanceTransferHelpForm.Show()
end

-- help popup for item exchange
function MainWindowForm_MainWindowForm_button_help_itemexchangeClick(sender)
  ItemExchangeHelpForm.Show()
end

function MainWindowForm_button_resetClick(sender)
  resetState()
  initTimer()
end

function MainWindowForm_FormShow(sender)
  resetState()
  initTimer()
end

function MainWindowForm_FormClose(sender)
  closeCE()
  return caHide
end

initCardCheckboxes()
MainWindowForm.Show()
</LuaScript>
</CheatTable>
